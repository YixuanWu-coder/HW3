/*
--Answer following questions
--1.In SQL Server, assuming you can find the result by using both joins and subqueries, which one would you prefer to use and why?
I prefer JOIN. Because in most cases, JOIN will have a better performance than subquery.

--2.What is CTE and when to use it?
  CTE represents common table expression. It is a temporary named result set to make our query more readable.

--3.What are Table Variables? What is their scope and where are they created in SQL Server?
table variables are created and defined similarly to a table, only with a strictly defined lifetime scope.

--4.What is the difference between DELETE and TRUNCATE? Which one will have better performance and why?
Truncate removes all records and doesn't fire triggers.
Truncate is not possible when a table is referenced by a Foreign Key or tables are used in replication or with indexed views.
TRUNCATE is faster performance than delete

--5.What is Identity column? How does DELETE and TRUNCATE affect it?
An identity column is a column in a database table that is made up of values generated by the database.
Delete not reset but keep on increasing.
TRUNCATE resets the identity value to the original seed value of the table.

--6.What is difference between ¡°delete from table_name¡± and ¡°truncate table table_name¡±?
Its all delete all rows from table, but truncate cannot rollback the changes.
*/


--All scenarios are based on Database NORTHWND.
--1.	List all cities that have both Employees and Customers.
SELECT DISTINCT e.City
FROM Employees e INNER JOIN Customers c ON e.City=c.City

--2.	List all cities that have Customers but no Employee.
--      a.	Use sub-query
--      b.	Do not use sub-query
--a)
SELECT DISTINCT CITY
FROM CUSTOMERS
WHERE CITY NOT IN (SELECT CITY FROM EMPLOYEES)
--b)
SELECT DISTINCT e.City
FROM Employees e LEFT JOIN Customers c ON e.City=c.City

--3.	List all products and their total order quantities throughout all orders.
SELECT c.CustomerID, c. CompanyName,c.ContactName
SUM(od.Quantity) as qty from
customers c
LEFT JOIN
orders o ON c.CustomerID=o.CustomerID
LEFT JOIN
"ORDER DETAILS" od ON o.orderID=od.orderID
GROUP BY c.CustomerID, c. CompanyName,c.ContactName
order by qty DESC

--4.	List all Customer Cities and total products ordered by that city.
SELECT c.City
SUM(od.Quantity) AS QTY 
FROM Customers c LEFT JOIN Orders o ON c. CustomerID = o. CustomerID LEFT JOIN [ Order Details ] od ON o. OrderID = od . OrderID GROUP BY c. City ORDER BY QTY desc

--5.	List all Customer Cities that have at least two customers.
--      a.	Use union
select u.City from Customers u group by u.City having COUNT(u.City) > 2 
union 
select c.City from Customers c group by c.City having COUNT(c.City) = 2
--		b.	Use sub-query and no union
select distinct c.City from Customers c
where c.City in 
(select u.City from Customers u group by u.City having COUNT(u.City) >=
2 )


--6.	List all Customer Cities that have ordered at least two different kinds of products.
select distinct c.City
from Orders o inner join Customers c
on o.CustomerID = c.CustomerID
inner join [Order Details] r
on r.OrderID = o.OrderID
group by c.City, r.ProductID
having count(r.ProductID) > 2

--7.	List all Customers who have ordered products, but have the ¡®ship city¡¯ on the order different from their own customer cities.
select * from Customers c
where c.City not in 
(select o.ShipCity from Orders o inner join Customers c on o.ShipCity = c.City)

--8.	List 5 most popular products, their average price, and the customer city that ordered most quantity of it.
WITH cte_ordersc
as(
SELECT oc.ShipCity,oc.ProductID, oc.average,DENSE_RANK() over (partition by
oc.ProductID order by oc.number) rnk FROM (
SELECT TOP(5) od.ProductID,o.ShipCity, SUM(Quantity) number,AVG(od.UnitPrice)
average FROM dbo.Orders o left join dbo.[Order Details] od on o.OrderID=od.OrderID
GROUP BY o.ShipCity, od.ProductID
ORDER BY number DESC
) oc
)
select * from cte_ordersc where rnk=1

--9.	List all cities that have never ordered something but we have employees there.
--		a.	Use sub-query
select e.City from Employees e
where e.City not in (
select c.City from Orders o inner join Customers c
on c.CustomerID = o.CustomerID)
--		b.	Do not use sub-query
select distinct e.City from Employees e
left join Customers c
on e.City = c.City
where c.City is null

--10.	List one city, if exists, that is the city from where the employee sold most orders (not the product quantity) is, and also the city of most total quantity of products ordered from. (tip: join  sub-query)
select * from 
(select Top 1 e.City, count(o.OrderID) countOrder from Employees e inner join Orders o
on e.EmployeeID = o.EmployeeID
group by e.City) T1
inner join (
select Top 1 c.City, count(r.Quantity) countQuantity from [Order Details] r inner join
Orders d on r.OrderID = d.OrderID
inner join Customers c on c.CustomerID = d.CustomerID group by c.City) T2
on T1.City = T2.City;

--11.   How do you remove the duplicates record of a table?
delete

--12.   Sample table to be used for solutions below- Employee (empid integer, mgrid integer, deptid integer, salary money) Dept (deptid integer, deptname varchar(20))
--		Find employees who do not manage anybody.
SELECT deptname,empid,salary
FROM(
SELECT d.deptname, e.empid, e.salary, rank() OVER ( PARTITION BY e.deptid ORDER BY 
 e.salary DESC ) AS rnk
 FROM dept d, employee e
 WHERE d.deptid = e.deptid
 )
WHERE rnk <= 3
ORDER BY deptname,rnk

--13.   Find departments that have maximum number of employees. (solution should consider scenario having more than 1 departments that have maximum number of employees). Result should only have - deptname, count of employees sorted by deptname.
select countbydept.*
from (
select deptid, count(*) as departCount
from Employee
group by deptid
order by departCount desc
limit 1
) as maxcount


--14.   Find top 3 employees (salary based) in every department. Result should have deptname, empid, salary sorted by deptname and then employee with high to low salary.
SELECT deptname,empid,salary
FROM(
SELECT d.deptname,e.empid,e.salary,rank()OVER(PARTITION BY e.depid
ORDER BY e.salary desc) AS rnk
FROM dept. d,employee e
WHERE d.deptid = e.deptid
)
WHERE rnk <=3
ORDER BY deptname,rnk
